#' @export
new_zoned_time <- function(sys_time = sys_seconds(),
                           zone = "UTC",
                           ...,
                           names = NULL,
                           class = NULL) {
  if (!is_string(zone)) {
    abort("`zone` must be a string.")
  }
  if (!is_sys_time(sys_time)) {
    abort("`sys_time` must be a 'clock_sys_time'.")
  }
  if (time_point_precision(sys_time) < PRECISION_SECOND) {
    abort("`sys_time` must be at least second precision.")
  }

  fields <- list(sys_time = sys_time)

  new_clock_rcrd(
    fields = fields,
    zone = zone,
    ...,
    names = names,
    class = c(class, "clock_zoned_time")
  )
}

#' @export
is_zoned_time <- function(x) {
  inherits(x, "clock_zoned_time")
}

# ------------------------------------------------------------------------------

zoned_time_zone <- function(x) {
  attr(x, "zone", exact = TRUE)
}
zoned_time_set_zone <- function(x, zone) {
  attr(x, "zone") <- zone
  x
}

zoned_time_sys_time <- function(x) {
  field(x, "sys_time")
}
zoned_time_naive_time <- function(x) {
  sys_time <- zoned_time_sys_time(x)
  zone <- zoned_time_zone(x)

  duration <- time_point_duration(sys_time)
  precision <- time_point_precision(sys_time)

  fields <- get_naive_time_cpp(duration, precision, zone)
  duration <- new_duration_from_fields(fields, precision)

  new_naive_time(duration)
}

zoned_time_precision <- function(x) {
  time_point_precision(zoned_time_sys_time(x))
}

# ------------------------------------------------------------------------------

#' @export
format.clock_zoned_time <- function(x,
                                    ...,
                                    format = NULL,
                                    locale = default_date_locale(),
                                    abbreviate_zone = FALSE) {
  if (!is_date_locale(locale)) {
    abort("`locale` must be a date locale object.")
  }

  zone <- zoned_time_zone(x)
  sys_time <- zoned_time_sys_time(x)
  duration <- time_point_duration(sys_time)
  precision <- duration_precision(duration)

  if (is_null(format)) {
    # Collect internal option
    print_zone_name <- zoned_time_print_zone_name(...)
    format <- zoned_time_format(print_zone_name)
  }

  date_names <- locale$date_names
  decimal_mark <- locale$decimal_mark

  out <- format_zoned_time_cpp(
    fields = duration,
    zone = zone,
    abbreviate_zone = abbreviate_zone,
    format = format,
    precision_int = precision,
    mon = date_names$mon,
    mon_ab = date_names$mon_ab,
    day = date_names$day,
    day_ab = date_names$day_ab,
    am_pm = date_names$am_pm,
    decimal_mark = decimal_mark
  )

  names(out) <- names(x)

  out
}

zoned_time_print_zone_name <- function(..., print_zone_name = TRUE) {
  print_zone_name
}
zoned_time_format <- function(print_zone_name) {
  if (print_zone_name) {
    "%Y-%m-%dT%H:%M:%S%Ez[%Z]"
  } else {
    "%Y-%m-%dT%H:%M:%S%Ez"
  }
}

# ------------------------------------------------------------------------------

#' @export
vec_proxy.clock_zoned_time <- function(x, ...) {
  names <- names(x)
  zoned_time_proxy(x, names)
}

zoned_time_proxy <- function(x, names = NULL) {
  x <- zoned_time_sys_time(x)
  time_point_proxy(x, names)
}

#' @export
vec_restore.clock_zoned_time <- function(x, to, ...) {
  names <- clock_rcrd_restore_names(x)
  zoned_time_restore(x, to, names)
}

zoned_time_restore <- function(x, to, names = NULL) {
  zone <- zoned_time_zone(to)
  to <- zoned_time_sys_time(to)
  x <- time_point_restore(x, to)
  new_zoned_time(x, zone, names = names)
}

#' @export
vec_proxy_equal.clock_zoned_time <- function(x, ...) {
  # ptype2 / cast will prevent zoned times with different zones from being
  # compared, so the equality proxy doesn't need to worry about zone.
  zoned_time_proxy_equal(x)
}

zoned_time_proxy_equal <- function(x) {
  x <- zoned_time_sys_time(x)
  time_point_proxy_equal(x)
}

# ------------------------------------------------------------------------------

#' @export
vec_ptype_full.clock_zoned_time <- function(x, ...) {
  zone <- zone_pretty(zoned_time_zone(x))
  precision <- zoned_time_precision(x)
  precision <- precision_to_string(precision)
  paste0("zoned_time<", precision, "><", zone, ">")
}

#' @export
vec_ptype_abbr.clock_zoned_time <- function(x, ...) {
  zone <- zone_pretty(zoned_time_zone(x))
  precision <- zoned_time_precision(x)
  precision <- precision_to_string(precision)
  precision <- precision_abbr(precision)
  paste0("zt<", precision, "><", zone, ">")
}

zone_pretty <- function(zone) {
  if (identical(zone, "")) {
    zone <- zone_current()
    zone <- paste0(zone, " (current)")
  }
  zone
}

# ------------------------------------------------------------------------------

#' @export
vec_ptype2.clock_zoned_time.clock_zoned_time <- function(x, y, ...) {
  x_zone <- zoned_time_zone(x)
  y_zone <- zoned_time_zone(y)

  if (x_zone != y_zone) {
    stop_incompatible_type(x, y, ..., details = "Zones can't differ.")
  }

  x_precision <- zoned_time_precision(x)
  y_precision <- zoned_time_precision(y)

  if (x_precision >= y_precision) {
    x
  } else {
    y
  }
}

#' @export
vec_cast.clock_zoned_time.clock_zoned_time <- function(x, to, ...) {
  x_zone <- zoned_time_zone(x)
  to_zone <- zoned_time_zone(to)

  if (x_zone != to_zone) {
    stop_incompatible_cast(x, to, ..., details = "Zones can't differ.")
  }

  x_sys_time <- zoned_time_sys_time(x)
  to_sys_time <- zoned_time_sys_time(to)

  x_duration <- time_point_duration(x_sys_time)
  to_duration <- time_point_duration(to_sys_time)

  x_precision <- duration_precision(x_duration)
  to_precision <- duration_precision(to_duration)

  if (x_precision == to_precision) {
    return(x)
  }

  if (x_precision > to_precision) {
    stop_incompatible_cast(x, to, ..., details = "Precision would be lost.")
  }

  duration <- duration_cast_impl(x_duration, to_precision)

  sys_time <- new_sys_time(duration)

  new_zoned_time(sys_time, x_zone, names = names(x))
}

# ------------------------------------------------------------------------------

# - Pass through internal option to not print zone name
# - Unlike vctrs, don't use `print(quote = FALSE)` since we want to match base R
#' @export
obj_print_data.clock_zoned_time <- function(x, ...) {
  if (vec_size(x) == 0L) {
    return(invisible(x))
  }

  out <- format(x, print_zone_name = FALSE)
  print(out)

  invisible(x)
}

# Align left to match pillar_shaft.Date
# @export - lazy in .onLoad()
pillar_shaft.clock_zoned_time <- function(x, ...) {
  out <- format(x, print_zone_name = FALSE)
  pillar::new_pillar_shaft_simple(out, align = "left")
}

# ------------------------------------------------------------------------------

#' @export
as_zoned_time <- function(x, ...) {
  UseMethod("as_zoned_time")
}

#' @export
as_zoned_time.default <- function(x, ...) {
  stop_clock_unsupported_conversion(x, "clock_zoned_time")
}

#' @export
as_zoned_time.clock_zoned_time <- function(x, ...) {
  x
}

# ------------------------------------------------------------------------------

#' @export
as_sys_time.clock_zoned_time <- function(x) {
  out <- zoned_time_sys_time(x)
  names(out) <- names(x)
  out
}

#' @export
as_naive_time.clock_zoned_time <- function(x) {
  out <- zoned_time_naive_time(x)
  names(out) <- names(x)
  out
}

# ------------------------------------------------------------------------------

#' @export
zoned_now <- function(zone) {
  sys_time <- sys_now()
  zone <- zone_validate(zone)
  new_zoned_time(sys_time, zone = zone)
}

# ------------------------------------------------------------------------------

#' Retrieve or set the time zone
#'
#' @description
#' `zoned_zone()` retrieves the time zone.
#'
#' `zoned_set_zone()` sets the time zone _without changing the
#' underlying instant_. This means that the result will represent the equivalent
#' time in the new time zone.
#'
#' @param x `[zoned_time / Date / POSIXt]`
#'
#'   A zoned time to get or set the time zone of.
#'
#' @param zone `[character(1)]`
#'
#'   A valid time zone to switch to.
#'
#' @return
#' `zoned_zone()` returns a string containing the time zone.
#'
#' `zoned_set_zone()` returns `x` with an altered time zone attribute. The
#' underlying instant is _not_ changed.
#'
#' @name zoned-zone
#'
#' @examples
#' x <- as.POSIXct("2019-01-01 00:00:00", tz = "America/New_York")
#'
#' zoned_zone(x)
#'
#' # Equivalent UTC time
#' zoned_set_zone(x, "UTC")
#'
#' y <- as_zoned_time(x)
#'
#' # With a zoned-time
#' zoned_set_zone(y, "UTC")
#'
#' # To force a new time zone with the same wall time,
#' # convert to a naive time that has no implied time zone,
#' # then convert back to a zoned time in the new time zone.
#' nt <- as_naive_time(y)
#' nt
#' as_zoned_time(nt, "UTC")
NULL

#' @rdname zoned-zone
#' @export
zoned_zone <- function(x) {
  UseMethod("zoned_zone")
}

#' @export
zoned_zone.clock_zoned_time <- function(x) {
  zoned_time_zone(x)
}

#' @rdname zoned-zone
#' @export
zoned_set_zone <- function(x, zone) {
  UseMethod("zoned_set_zone")
}

#' @export
zoned_set_zone.clock_zoned_time <- function(x, zone) {
  zone <- zone_validate(zone)
  zoned_time_set_zone(x, zone)
}

# ------------------------------------------------------------------------------

#' Get the offset from UTC
#'
#' `zoned_offset()` returns the offset from UTC as a duration of seconds.
#'
#' @param x `[zoned_time / Date / POSIXt]`
#'
#'   A zoned time to extract the offset for.
#'
#' @return A seconds precision duration object the same size as `x`.
#' @export
#' @examples
#' # R defines Date as UTC
#' zoned_offset(as.Date("2019-01-01"))
#'
#' x <- year_month_day(2021, 03, 14, hour = c(1, 3))
#' x <- as_naive_time(x)
#' x <- as_zoned_time(x, "America/New_York")
#'
#' # Daylight savings time alters the offset from UTC
#' zoned_offset(x)
#'
#' # Can extract directly from POSIXct if you started with one of those
#' zoned_offset(as.POSIXct(x))
zoned_offset <- function(x) {
  UseMethod("zoned_offset")
}

#' @export
zoned_offset.clock_zoned_time <- function(x) {
  zone <- zoned_time_zone(x)
  sys_time <- zoned_time_sys_time(x)
  duration <- time_point_duration(sys_time)
  precision <- time_point_precision(sys_time)
  fields <- zoned_offset_cpp(duration, precision, zone)
  new_duration_from_fields(fields, precision = PRECISION_SECOND)
}

# ------------------------------------------------------------------------------

#' Is daylight saving time active?
#'
#' `zoned_dst()` detects if daylight saving time is currently active.
#'
#' @param x `[zoned_time / Date / POSIXt]`
#'
#'   A zoned time to check if daylight saving time is active for.
#'
#' @return A logical the same size as `x`. Returns `TRUE` if daylight saving
#'   time is active, `FALSE` if not, and `NA` if `x` is `NA`.
#' @export
#' @examples
#' # R defines Date as UTC, where DST is never active
#' zoned_dst(as.Date("2019-01-01"))
#'
#' x <- year_month_day(2021, 03, 14, hour = c(1, 3))
#' x <- as_naive_time(x)
#' x <- as_zoned_time(x, "America/New_York")
#'
#' # Daylight savings time was turned on at 2am
#' zoned_dst(x)
zoned_dst <- function(x) {
  UseMethod("zoned_dst")
}

#' @export
zoned_dst.clock_zoned_time <- function(x) {
  zone <- zoned_time_zone(x)
  sys_time <- zoned_time_sys_time(x)
  sys_time <- time_point_cast(sys_time, "second")
  duration <- time_point_duration(sys_time)
  zoned_dst_cpp(duration, zone)
}

# ------------------------------------------------------------------------------

zone_validate <- function(zone) {
  zone <- zone_standardize(zone)

  if (!zone_is_valid(zone)) {
    message <- paste0("'", zone, "' is not a known time zone.")
    abort(message)
  }

  zone
}
